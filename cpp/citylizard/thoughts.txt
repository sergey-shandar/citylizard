cast: 

1.	Only value casting, no references. if you need references, use pointers.
	For example:
		A &a = *cast::dynamic_(&b);

2.	Two types of values accepted: 
		-	F const & 
		-	F &&.

3.	Analisys of convertions:

		static_cast           | val ref ptr

					val: (T &x)       => F
					     (T const &x) => F
					     (T &&x)      => F

					ref: (T &x)       => F &, F const &, F &&
					     (T const &x) => F const &
					     (T &&x)      => F const &, F &&

					ptr: (T *p)       => F *

		const_cast            |     ref ptr

					ref: (T const &x) => F &, F &&, F const &
					ptr: (T const *p) => F *

	        dynamic_cast          |     ref ptr

					ref: (T &&x) => F &&
                                             (T const &x) => F const &
					     (T &&x)

        	reinterpret_cast      | val ref ptr
        
		explicit              | val
 
        	default               | val

	        polymorphic_cast      |     ref ptr
        	polymorphic_downcast  |     ref ptr

	        c                     | val ref ptr
		safe_reinterpret_cast | val ref ptr

	Summary (all by value):

		T reinterpret(F const &v)

		T safe_reinterpret_cast(F const &)

		T static_(F &&v)

		T explicit_(F &&v)

		T implicit_(F &&v)

		T c(F &&v)

		T default_()

		T *const_(F *p)
		T *dynamic(F *p)
		T *polymorphic(F *p)
		T *polymorphic_down(F *p)

	Anyway, this is shorter

		static_(v)
		*static_(&r)

	than this one

		static_::value(v)
		static_::ref(r)